<html>

<head>
<title>Convex Hull Readme</title>
</head>

<body>
<table border=5 width=1000 align="center"><tr><td>

<h1 align="center">Convex Hull Readme</h1>
<h3 align="center">flash application by <a href="mailto:chris@cmu.edu">Christopher Salvarani</a></h3>

<h2>What does the program do?</h2>
The program finds the convex hull of a set of points inputted by the user using either Graham scan or Chan’s algorithm. It walks through the algorithm showing each step.

<h2>How do I run the program?</h2>
You run the program by opening the convex.html file. It will load the HTML page which embeds the flash program.

<h2>What is the input?</h2>
The input is a set of points. The user clicks various spots on the screen to input the points, and then when ready clicks the appropriate buttons on the bottom bar.

<h2>How does Chan's algorithm work?</h2>
Here is the pseudocode for Chan's algorithm:<br>
<div style="font-family:courier new">
<b>Input</b>: P∈ℝ² : |P|=n>0<br>
m=2<br>
Loop<br>
<table><tr><td><pre>&#9;</pre></td><td>
	Parition P into P<sub>0</sub>,P<sub>1</sub>,...,P<sub>q</sub> where |P<sub>i</sub>|=m for all i&lt;q and |P<sub>q</sub>|>0<br>
	Run an O(nlogn) convex hull algorithm on each P<sub>i</sub>. Let CH<sub>i</sub> be the convex hull of P<sub>i</sub><br>
	Find leftmost point in P, call it left<br>
	Initialize output to empty stack (we refer to the top of the stack as output<sub>0</sub>)<br>
	output.push(left)<br>
	Repeat m times<br>
	<table><tr><td><pre>&#9;</pre></td><td>
		For each CH<sub>i</sub>, find the point in CH<sub>i</sub> which is rightmost from output<sub>0</sub>, call it r<sub>i</sub><br>
		Find the point in {r<sub>0</sub>,r</sub>1</sub>,...,r<sub>q</sub>} which is rightmost from output<sub>0</sub>, call it right<br>
		output.push(right)<br>
		if left = right, return output
	</td></tr></table>
	m = MIN(n,m²)<br>
</td></tr></table>
</div>
<p>Chan’s algorithm works by guessing h (the number of points on the convex hull) to be m (initial guess of 2 is acceptable), and then dividing the set of points into O(n/m) subsets of O(m) points and computing the convex hull of each of these with an O(nlogn) algorithm (like Graham scan). This takes O(nlogm).</p>
<p>It then uses a variation of Jarvis march (a naïve O(nh) convex hull algorithm) in conjunction with the already computed convex hulls to construct the convex hull. Jarvis march is sped up to O(nlogm) using the pre-computed mini-hulls, which we can search using a variation of binary search. If the value for m guessed was too low (we figure this out when we take m steps and have not returned to the starting vertex), we bail out and try a greater value for m (the square of m) without exceeding n.</p>

<h2>What is the runing time of Chan's algorithm?</h2>
<p><table><tr>
</td>
	Each iteration of Chan's algorithm has a running time of O(nlogm)
</td>
<td><ul>
	<li>Partitioning P takes O(n).
	<li>Finding the convex hull of a single partition takes O(mlogm), and we do it O(n/m) times. So, this takes O(nlogm).
	<li>Finding the leftmost point in P takes O(n).
	<li>Finding the rightmost points in each partition takes O(n/m*logm) (O(logm) for each using binary search on the convex hull). Finding the rightmost of these takes O(n/m), so O(n/m*logm) dominates. We repeat this m times, so this takes O(nlogm).
</ul></td>
</tr></table></p>
<p>Summing over each iteration gives us:<br>
<table><tr><td><pre>&#9;</pre></td><td>
<img src="summation.png">
</td></tr></table>
</p>
<p>So, Chan’s algorithm has an overall running time of O(nlogh).</p>

<h1 align="center"><a href='javascript:history.go(-1)>Back</a></h1>

</td></tr></table>
</body>

</html>